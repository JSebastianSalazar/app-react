/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
 * @format
 */

"use strict";
var _slicedToArray = (function() {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;
    try {
      for (
        var _i = arr[Symbol.iterator](), _s;
        !(_n = (_s = _i.next()).done);
        _n = true
      ) {
        _arr.push(_s.value);
        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
  return function(arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError(
        "Invalid attempt to destructure non-iterable instance"
      );
    }
  };
})();
function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
      arr2[i] = arr[i];
    return arr2;
  } else {
    return Array.from(arr);
  }
}

const getAppendScripts = require("../../lib/getAppendScripts");
var _require = require("./helpers/js");
const isJsModule = _require.isJsModule,
  wrapModule = _require.wrapModule;

const PRAGMA = "//# offsetTable=";

// TODO(T34761193): This logic is shared across all serializers.
function processModules(modules, _ref) {
  let filter = _ref.filter,
    createModuleId = _ref.createModuleId,
    dev = _ref.dev,
    projectRoot = _ref.projectRoot;
  return []
    .concat(_toConsumableArray(modules))
    .filter(isJsModule)
    .filter(filter)
    .map(module => [
      module,
      wrapModule(module, {
        createModuleId,
        dev,
        projectRoot
      })
    ]);
}

function generateSource(modules, offset) {
  let output = "";
  const table = [];
  for (const _ref2 of modules) {
    var _ref3 = _slicedToArray(_ref2, 2);
    const id = _ref3[0];
    const code = _ref3[1];
    table.push([id, code.length]);
    output += code + "\n";
  }
  // Remove the extraneous line break at the end.
  return [table, output.slice(0, -1)];
}

function plainJSBundle(entryPoint, preModules, graph, options) {
  for (const module of graph.dependencies.values()) {
    options.createModuleId(module.path);
  }

  const processModulesOptions = {
    filter: options.processModuleFilter,
    createModuleId: options.createModuleId,
    dev: options.dev,
    projectRoot: options.projectRoot
  };

  const preCode = processModules(preModules, processModulesOptions)
    .map(_ref4 => {
      var _ref5 = _slicedToArray(_ref4, 2);
      let _ = _ref5[0],
        code = _ref5[1];
      return code;
    })
    .join("\n");

  const postCode = processModules(
    getAppendScripts(entryPoint, preModules, graph, {
      createModuleId: options.createModuleId,
      getRunModuleStatement: options.getRunModuleStatement,
      runBeforeMainModule: options.runBeforeMainModule,
      runModule: options.runModule,
      sourceMapUrl: options.sourceMapUrl,
      inlineSourceMap: options.inlineSourceMap
    }),

    processModulesOptions
  )
    .map(_ref6 => {
      var _ref7 = _slicedToArray(_ref6, 2);
      let _ = _ref7[0],
        code = _ref7[1];
      return code;
    })
    .join("\n");
  var _generateSource = generateSource(
      processModules(
        [].concat(_toConsumableArray(graph.dependencies.values())),
        processModulesOptions
      )
        .map(_ref8 => {
          var _ref9 = _slicedToArray(_ref8, 2);
          let module = _ref9[0],
            code = _ref9[1];
          return [options.createModuleId(module.path), code];
        })
        // Sorting the modules by id ensures that our build output is
        // deterministic by id. This is necessary for delta bundle clients to be
        // able to re-generate plain js bundles that match the output of this
        // function. Otherwise, source maps wouldn't work properly for delta
        // bundles.
        .sort((a, b) => a[0] - b[0]),
      preCode.length + 1
    ),
    _generateSource2 = _slicedToArray(_generateSource, 2);
  const modules = _generateSource2[0],
    modulesCode = _generateSource2[1];

  return [preCode, modulesCode, postCode]
    .concat(
      _toConsumableArray(
        options.embedDelta
          ? [
              PRAGMA +
                JSON.stringify({
                  pre: preCode.length,
                  post: postCode.length,
                  modules,
                  revisionId: options.revisionId
                })
            ]
          : []
      )
    )
    .join("\n");
}

module.exports = plainJSBundle;
