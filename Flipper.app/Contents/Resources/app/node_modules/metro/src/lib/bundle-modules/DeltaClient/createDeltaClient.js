/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *  strict-local
 * @format
 */

/* eslint-env worker, serviceworker */

"use strict";
let fetchBundle = (() => {
  var _ref = _asyncToGenerator(function*(bundleReq) {
    const bundleRes = yield fetch(bundleReq, {
      includeCredentials: true
    });

    return stringToBundle(yield bundleRes.text());
  });
  return function fetchBundle(_x) {
    return _ref.apply(this, arguments);
  };
})();
let defaultGetDeltaBundle = (() => {
  var _ref2 = _asyncToGenerator(function*(bundleReq, revisionId) {
    const url = new URL(bundleReq.url);
    url.pathname = url.pathname.replace(/\.(bundle|js)$/, ".delta");
    url.searchParams.append("revisionId", revisionId);
    const res = yield fetch(url.href, {
      includeCredentials: true
    });

    return yield res.json();
  });
  return function defaultGetDeltaBundle(_x2, _x3) {
    return _ref2.apply(this, arguments);
  };
})();
function _asyncToGenerator(fn) {
  return function() {
    var gen = fn.apply(this, arguments);
    return new Promise(function(resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }
        if (info.done) {
          resolve(value);
        } else {
          return Promise.resolve(value).then(
            function(value) {
              step("next", value);
            },
            function(err) {
              step("throw", err);
            }
          );
        }
      }
      return step("next");
    });
  };
}
const WebSocketHMRClient = require("../WebSocketHMRClient");
const bundleCache = require("./bundleCache");
const bundleToString = require("./bundleToString");
const patchBundle = require("./patchBundle");
const stringToBundle = require("./stringToBundle");
function defaultGetHmrServerUrl(bundleReq, revisionId) {
  const bundleUrl = new URL(bundleReq.url);
  return `${bundleUrl.protocol === "https:" ? "wss" : "ws"}://${
    bundleUrl.host
  }/hot?revisionId=${revisionId}`;
}

function defaultOnUpdate(clientId, update) {
  clients.get(clientId).then(client => {
    if (client != null) {
      client.postMessage({
        type: "METRO_UPDATE",
        update
      });
    }
  });
}

function defaultOnUpdateStart(clientId) {
  clients.get(clientId).then(client => {
    if (client != null) {
      client.postMessage({
        type: "METRO_UPDATE_START"
      });
    }
  });
}

function defaultOnUpdateError(clientId, error) {
  clients.get(clientId).then(client => {
    if (client != null) {
      client.postMessage({
        type: "METRO_UPDATE_ERROR",
        error
      });
    }
  });
}

function createDeltaClient() {
  var _ref3 =
      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    _ref3$getHmrServerUrl = _ref3.getHmrServerUrl;
  let getHmrServerUrl =
    _ref3$getHmrServerUrl === undefined
      ? defaultGetHmrServerUrl
      : _ref3$getHmrServerUrl;
  var _ref3$getDeltaBundle = _ref3.getDeltaBundle;
  let getDeltaBundle =
    _ref3$getDeltaBundle === undefined
      ? defaultGetDeltaBundle
      : _ref3$getDeltaBundle;
  var _ref3$onUpdateStart = _ref3.onUpdateStart;
  let onUpdateStart =
    _ref3$onUpdateStart === undefined
      ? defaultOnUpdateStart
      : _ref3$onUpdateStart;
  var _ref3$onUpdate = _ref3.onUpdate;
  let onUpdate =
    _ref3$onUpdate === undefined ? defaultOnUpdate : _ref3$onUpdate;
  var _ref3$onUpdateError = _ref3.onUpdateError;
  let onUpdateError =
    _ref3$onUpdateError === undefined
      ? defaultOnUpdateError
      : _ref3$onUpdateError;
  const clientsByRevId = new Map();

  return (() => {
    var _ref4 = _asyncToGenerator(function*(event) {
      const clientId = event.clientId;
      const bundleReq = event.request;

      let bundle = yield bundleCache.getBundle(bundleReq);

      if (bundle == null) {
        // We couldn't retrieve a delta bundle from either the delta cache nor the
        // browser cache. This can happen when the browser cache is cleared but the
        // service worker survives. In this case, we retrieve the original bundle.
        bundle = yield fetchBundle(bundleReq);
      } else if (!__DEV__) {
        try {
          const delta = yield getDeltaBundle(bundleReq, bundle.revisionId);
          bundle = patchBundle(bundle, delta);
        } catch (error) {
          console.error("[SW] Error retrieving delta bundle", error);
          bundle = yield fetchBundle(bundleReq);
        }
      } else {
        const clientIds = clientsByRevId.get(bundle.revisionId);
        if (clientIds != null) {
          // There's already an update client running for this particular
          // revision id.
          clientIds.add(clientId);
        } else {
          const clientIds = new Set([clientId]);
          clientsByRevId.set(bundle.revisionId, clientIds);

          try {
            let currentBundle = bundle;

            bundle = yield new Promise(function(resolve, reject) {
              let resolved = false;
              const wsClient = new WebSocketHMRClient(
                getHmrServerUrl(bundleReq, currentBundle.revisionId)
              );

              wsClient.on("connection-error", function(error) {
                reject(error);
              });

              wsClient.on("close", function() {
                clientsByRevId.delete(currentBundle.revisionId);
              });

              wsClient.on("error", function(error) {
                if (!resolved) {
                  reject(error);
                  return;
                }
                clientIds.forEach(function(clientId) {
                  return onUpdateError(clientId, error);
                });
              });

              wsClient.on("update-start", function() {
                clientIds.forEach(function(clientId) {
                  return onUpdateStart(clientId);
                });
              });

              wsClient.on("update", function(update) {
                if (resolved) {
                  // Only notify clients for later updates.
                  clientIds.forEach(function(clientId) {
                    return onUpdate(clientId, update);
                  });
                }

                // Transfers all clients to the new revision id.
                clientsByRevId.delete(currentBundle.revisionId);
                clientsByRevId.set(update.revisionId, clientIds);

                currentBundle = patchBundle(currentBundle, {
                  base: false,
                  revisionId: update.revisionId,
                  modules: update.modules,
                  deleted: update.deleted
                });

                bundleCache.setBundle(bundleReq, currentBundle);

                if (!resolved) {
                  resolved = true;
                  resolve(currentBundle);
                }
              });

              wsClient.enable();
            });
          } catch (error) {
            console.error(
              "[SW] Error connecting to the update server. Try refreshing the page.",
              error
            );

            bundle = yield fetchBundle(bundleReq);
          }
        }
      }

      bundleCache.setBundle(bundleReq, bundle);

      const bundleString = bundleToString(bundle);
      const bundleStringRes = new Response(bundleString, {
        status: 200,
        statusText: "OK",
        headers: new Headers({
          "Cache-Control": "no-cache",
          "Content-Length": String(bundleString.length),
          "Content-Type": "application/javascript",
          Date: new Date().toUTCString()
        })
      });

      return bundleStringRes;
    });
    return function(_x5) {
      return _ref4.apply(this, arguments);
    };
  })();
}

module.exports = createDeltaClient;
