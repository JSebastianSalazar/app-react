/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *  strict-local
 * @format
 */

/* eslint-env worker, serviceworker */

"use strict";
let getBundleFromBrowserCache = (() => {
  var _ref = _asyncToGenerator(function*(bundleReq) {
    const res = yield fetch(bundleReq, {
      // This forces using the browser cache, in which the initial bundle request
      // will have been stored.
      cache: "force-cache"
    });

    if (!res) {
      return null;
    }

    return stringToBundle(yield res.text());
  });
  return function getBundleFromBrowserCache(_x) {
    return _ref.apply(this, arguments);
  };
})();
let getBundleFromCustomCache = (() => {
  var _ref2 = _asyncToGenerator(function*(cache, bundleReq) {
    const res = yield cache.match(bundleReq);
    if (!res) {
      return null;
    }
    return yield res.json();
  });
  return function getBundleFromCustomCache(_x2, _x3) {
    return _ref2.apply(this, arguments);
  };
})();

/**
 * Retrieves a bundle from either the custom bundle cache or the browser cache.
 */ let getBundle = (() => {
  var _ref3 = _asyncToGenerator(function*(bundleReq) {
    const cache = yield caches.open(BUNDLE_CACHE_NAME);

    const deltaBundle = yield getBundleFromCustomCache(cache, bundleReq);
    if (deltaBundle != null) {
      return deltaBundle;
    }

    return yield getBundleFromBrowserCache(bundleReq);
  });
  return function getBundle(_x4) {
    return _ref3.apply(this, arguments);
  };
})();

/**
 * Stores a bundle in the custom bundle cache.
 */ let setBundle = (() => {
  var _ref4 = _asyncToGenerator(function*(bundleReq, bundle) {
    const bundleJson = JSON.stringify(bundle);
    const bundleJsonRes = new Response(bundleJson, {
      status: 200,
      statusText: "OK",
      headers: new Headers({
        "Content-Length": String(bundleJson.length),
        "Content-Type": "application/json",
        Date: new Date().toUTCString()
      })
    });

    const cache = yield caches.open(BUNDLE_CACHE_NAME);

    // Store the new initial bundle in cache. We don't need to wait for
    // this operation to complete before returning a response.
    yield cache.put(bundleReq, bundleJsonRes);
  });
  return function setBundle(_x5, _x6) {
    return _ref4.apply(this, arguments);
  };
})();
function _asyncToGenerator(fn) {
  return function() {
    var gen = fn.apply(this, arguments);
    return new Promise(function(resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }
        if (info.done) {
          resolve(value);
        } else {
          return Promise.resolve(value).then(
            function(value) {
              step("next", value);
            },
            function(err) {
              step("throw", err);
            }
          );
        }
      }
      return step("next");
    });
  };
}
const stringToBundle = require("./stringToBundle");
const BUNDLE_CACHE_NAME = "__metroBundleCache";

module.exports = { getBundle, setBundle };
